package ch3.sec2.title1;

/**
 * 3.2.1 函数式接口
 *
 * 为了参数化filter方法的行为而创建的Predicate<T>接口吗？它就
 * 是一个函数式接口！为什么呢？因为Predicate仅仅定义了一个抽象方法
 *
 * 一言以蔽之，函数式接口就是只定义一个抽象方法的接口。你已经知道了Java API中的一些
 * 其他函数式接口，如我们在第2章中谈到的Comparator和Runnable
 *
 *
 * 你将会在第9章中看到，接口现在还可以拥有默认方法（即在类没有对方法进行实现时，
 * 其主体为方法提供默认实现的方法）。哪怕有很多默认方法，只要接口只定义了一个抽象
 * 方法，它就仍然是一个函数式接口
 */
public class Concept {
    /**
     * Lambda表达式允许你直接以内联的形式为函数式接口的抽象
     * 方法提供实现，并把整个表达式作为函数式接口的实例（具体说来，是函数式接口一个具体实现
     * 的实例）。
     */

    /**
     * 你可能会想：“为什么只有在需要函数式接口的时候才可以传递Lambda呢？”语言的设计者
     * 也考虑过其他办法，例如给Java添加函数类型（有点儿像我们介绍的描述Lambda表达式签名的特
     * 殊表示法，我们会在第15章和第16章回过来讨论这个问题）。但是他们选择了现在这种方式，因
     * 为这种方式自然且能避免语言变得更复杂。
     */
}
